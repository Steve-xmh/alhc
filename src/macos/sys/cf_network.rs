#![allow(unused)]
#![allow(non_snake_case)]

use core_foundation::array::*;
use core_foundation::data::*;
use core_foundation::dictionary::*;
use core_foundation::runloop::*;
use core_foundation::string::*;
use core_foundation::url::*;

#[repr(C)]
pub struct __CFAllocator(::core::ffi::c_void);
#[repr(C)]
pub struct __CFError(::core::ffi::c_void);
#[repr(C)]
pub struct __CFReadStream(::core::ffi::c_void);
#[repr(C)]
pub struct __CFWriteStream(::core::ffi::c_void);
#[repr(C)]
pub struct __CFHost(::core::ffi::c_void);
#[repr(C)]
pub struct __CFNetService(::core::ffi::c_void);
#[repr(C)]
pub struct __CFNetServiceMonitor(::core::ffi::c_void);
#[repr(C)]
pub struct __CFNetServiceBrowser(::core::ffi::c_void);
#[repr(C)]
pub struct __CFHTTPMessage(::core::ffi::c_void);
#[repr(C)]
pub struct _CFHTTPAuthentication(::core::ffi::c_void);
#[repr(C)]
pub struct __CFNetDiagnostic(::core::ffi::c_void);

/* automatically generated by rust-bindgen 0.62.0 */

pub type UInt8 = ::core::ffi::c_uchar;
pub type SInt32 = ::core::ffi::c_int;
pub type Boolean = ::core::ffi::c_uchar;
pub type CFTypeID = ::core::ffi::c_ulong;
pub type CFOptionFlags = ::core::ffi::c_ulong;
pub type CFIndex = ::core::ffi::c_long;
pub type CFTypeRef = *const ::core::ffi::c_void;
pub type CFStringRef = *const __CFString;
pub type CFAllocatorRef = *const __CFAllocator;
pub type CFAllocatorRetainCallBack = ::core::option::Option<
    unsafe extern "C" fn(info: *const ::core::ffi::c_void) -> *const ::core::ffi::c_void,
>;
pub type CFAllocatorReleaseCallBack =
    ::core::option::Option<unsafe extern "C" fn(info: *const ::core::ffi::c_void)>;
pub type CFAllocatorCopyDescriptionCallBack =
    ::core::option::Option<unsafe extern "C" fn(info: *const ::core::ffi::c_void) -> CFStringRef>;
pub type CFArrayRef = *const __CFArray;
pub type CFDictionaryRef = *const __CFDictionary;
pub type CFTimeInterval = f64;
pub type CFDataRef = *const __CFData;
pub type CFErrorRef = *mut __CFError;
pub type CFURLRef = *const __CFURL;
pub type CFRunLoopRef = *mut __CFRunLoop;
pub type CFRunLoopSourceRef = *mut __CFRunLoopSource;
pub type CFReadStreamRef = *mut __CFReadStream;
pub type CFWriteStreamRef = *mut __CFWriteStream;
pub type CFNetworkErrors = ::core::ffi::c_int;
pub type CFHostRef = *mut __CFHost;
pub type CFHostInfoType = ::core::ffi::c_int;
pub type CFHostClientCallBack = ::core::option::Option<
    unsafe extern "C" fn(
        theHost: CFHostRef,
        typeInfo: CFHostInfoType,
        error: *const CFStreamError,
        info: *mut ::core::ffi::c_void,
    ),
>;
pub type CFNetServiceRef = *mut __CFNetService;
pub type CFNetServiceMonitorRef = *mut __CFNetServiceMonitor;
pub type CFNetServiceBrowserRef = *mut __CFNetServiceBrowser;
pub type CFNetServicesError = ::core::ffi::c_int;
pub type CFNetServiceMonitorType = ::core::ffi::c_int;
pub type CFNetServiceRegisterFlags = CFOptionFlags;
pub type CFNetServiceBrowserFlags = CFOptionFlags;
pub type CFNetServiceClientCallBack = ::core::option::Option<
    unsafe extern "C" fn(
        theService: CFNetServiceRef,
        error: *mut CFStreamError,
        info: *mut ::core::ffi::c_void,
    ),
>;
pub type CFNetServiceMonitorClientCallBack = ::core::option::Option<
    unsafe extern "C" fn(
        theMonitor: CFNetServiceMonitorRef,
        theService: CFNetServiceRef,
        typeInfo: CFNetServiceMonitorType,
        rdata: CFDataRef,
        error: *mut CFStreamError,
        info: *mut ::core::ffi::c_void,
    ),
>;
pub type CFNetServiceBrowserClientCallBack = ::core::option::Option<
    unsafe extern "C" fn(
        browser: CFNetServiceBrowserRef,
        flags: CFOptionFlags,
        domainOrService: CFTypeRef,
        error: *mut CFStreamError,
        info: *mut ::core::ffi::c_void,
    ),
>;
pub type CFHTTPMessageRef = *mut __CFHTTPMessage;
pub type CFStreamErrorHTTP = ::core::ffi::c_int;
pub type CFHTTPAuthenticationRef = *mut _CFHTTPAuthentication;
pub type CFStreamErrorHTTPAuthentication = ::core::ffi::c_int;
pub type CFNetDiagnosticRef = *mut __CFNetDiagnostic;
pub type CFNetDiagnosticStatusValues = ::core::ffi::c_int;
pub type CFNetDiagnosticStatus = CFIndex;
pub type CFProxyAutoConfigurationResultCallback = ::core::option::Option<
    unsafe extern "C" fn(
        client: *mut ::core::ffi::c_void,
        proxyList: CFArrayRef,
        error: CFErrorRef,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFStreamError {
    pub domain: CFIndex,
    pub error: SInt32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFStreamClientContext {
    pub version: CFIndex,
    pub info: *mut ::core::ffi::c_void,
    pub retain: ::core::option::Option<
        unsafe extern "C" fn(info: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(info: *mut ::core::ffi::c_void)>,
    pub copyDescription:
        ::core::option::Option<unsafe extern "C" fn(info: *mut ::core::ffi::c_void) -> CFStringRef>,
}
#[repr(C, packed(2))]
pub struct CFHostClientContext {
    pub version: CFIndex,
    pub info: *mut ::core::ffi::c_void,
    pub retain: CFAllocatorRetainCallBack,
    pub release: CFAllocatorReleaseCallBack,
    pub copyDescription: CFAllocatorCopyDescriptionCallBack,
}
#[repr(C, packed(2))]
pub struct CFNetServiceClientContext {
    pub version: CFIndex,
    pub info: *mut ::core::ffi::c_void,
    pub retain: CFAllocatorRetainCallBack,
    pub release: CFAllocatorReleaseCallBack,
    pub copyDescription: CFAllocatorCopyDescriptionCallBack,
}
#[test]
fn bindgen_test_layout_CFStreamError() {
    const UNINIT: ::core::mem::MaybeUninit<CFStreamError> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CFStreamError>(),
        16usize,
        concat!("Size of: ", stringify!(CFStreamError))
    );
    assert_eq!(
        ::core::mem::align_of::<CFStreamError>(),
        8usize,
        concat!("Alignment of ", stringify!(CFStreamError))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).domain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamError),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamError),
            "::",
            stringify!(error)
        )
    );
}
#[test]
fn bindgen_test_layout_CFStreamClientContext() {
    const UNINIT: ::core::mem::MaybeUninit<CFStreamClientContext> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CFStreamClientContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFStreamClientContext))
    );
    assert_eq!(
        ::core::mem::align_of::<CFStreamClientContext>(),
        8usize,
        concat!("Alignment of ", stringify!(CFStreamClientContext))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamClientContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamClientContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamClientContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamClientContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFStreamClientContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
#[test]
fn bindgen_test_layout_CFHostClientContext() {
    const UNINIT: ::core::mem::MaybeUninit<CFHostClientContext> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CFHostClientContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFHostClientContext))
    );
    assert_eq!(
        ::core::mem::align_of::<CFHostClientContext>(),
        2usize,
        concat!("Alignment of ", stringify!(CFHostClientContext))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFHostClientContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFHostClientContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFHostClientContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFHostClientContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFHostClientContext),
            "::",
            stringify!(copyDescription)
        )
    );
}
#[test]
fn bindgen_test_layout_CFNetServiceClientContext() {
    const UNINIT: ::core::mem::MaybeUninit<CFNetServiceClientContext> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CFNetServiceClientContext>(),
        40usize,
        concat!("Size of: ", stringify!(CFNetServiceClientContext))
    );
    assert_eq!(
        ::core::mem::align_of::<CFNetServiceClientContext>(),
        2usize,
        concat!("Alignment of ", stringify!(CFNetServiceClientContext))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CFNetServiceClientContext),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CFNetServiceClientContext),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).retain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CFNetServiceClientContext),
            "::",
            stringify!(retain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CFNetServiceClientContext),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).copyDescription) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CFNetServiceClientContext),
            "::",
            stringify!(copyDescription)
        )
    );
}

#[link(name = "CFNetwork", kind = "framework")]
extern "C" {
    pub static kCFErrorDomainCFNetwork: CFStringRef;
    pub static kCFErrorDomainWinSock: CFStringRef;
    pub static kCFURLErrorFailingURLErrorKey: CFStringRef;
    pub static kCFURLErrorFailingURLStringErrorKey: CFStringRef;
    pub static kCFGetAddrInfoFailureKey: CFStringRef;
    pub static kCFSOCKSStatusCodeKey: CFStringRef;
    pub static kCFSOCKSVersionKey: CFStringRef;
    pub static kCFSOCKSNegotiationMethodKey: CFStringRef;
    pub static kCFDNSServiceFailureKey: CFStringRef;
    pub static kCFFTPStatusCodeKey: CFStringRef;
    pub static kCFStreamErrorDomainNetDB: SInt32;
    pub static kCFStreamErrorDomainSystemConfiguration: SInt32;
    pub fn CFHostGetTypeID() -> CFTypeID;
    pub fn CFHostCreateWithName(allocator: CFAllocatorRef, hostname: CFStringRef) -> CFHostRef;
    pub fn CFHostCreateWithAddress(allocator: CFAllocatorRef, addr: CFDataRef) -> CFHostRef;
    pub fn CFHostCreateCopy(alloc: CFAllocatorRef, host: CFHostRef) -> CFHostRef;
    pub fn CFHostStartInfoResolution(
        theHost: CFHostRef,
        info: CFHostInfoType,
        error: *mut CFStreamError,
    ) -> Boolean;
    pub fn CFHostGetAddressing(theHost: CFHostRef, hasBeenResolved: *mut Boolean) -> CFArrayRef;
    pub fn CFHostGetNames(theHost: CFHostRef, hasBeenResolved: *mut Boolean) -> CFArrayRef;
    pub fn CFHostGetReachability(theHost: CFHostRef, hasBeenResolved: *mut Boolean) -> CFDataRef;
    pub fn CFHostCancelInfoResolution(theHost: CFHostRef, info: CFHostInfoType);
    pub fn CFHostSetClient(
        theHost: CFHostRef,
        clientCB: CFHostClientCallBack,
        clientContext: *mut CFHostClientContext,
    ) -> Boolean;
    pub fn CFHostScheduleWithRunLoop(
        theHost: CFHostRef,
        runLoop: CFRunLoopRef,
        runLoopMode: CFStringRef,
    );
    pub fn CFHostUnscheduleFromRunLoop(
        theHost: CFHostRef,
        runLoop: CFRunLoopRef,
        runLoopMode: CFStringRef,
    );
    pub static kCFStreamErrorDomainMach: SInt32;
    pub static kCFStreamErrorDomainNetServices: SInt32;
    pub fn CFNetServiceGetTypeID() -> CFTypeID;
    pub fn CFNetServiceMonitorGetTypeID() -> CFTypeID;
    pub fn CFNetServiceBrowserGetTypeID() -> CFTypeID;
    pub fn CFNetServiceCreate(
        alloc: CFAllocatorRef,
        domain: CFStringRef,
        serviceType: CFStringRef,
        name: CFStringRef,
        port: SInt32,
    ) -> CFNetServiceRef;
    pub fn CFNetServiceCreateCopy(
        alloc: CFAllocatorRef,
        service: CFNetServiceRef,
    ) -> CFNetServiceRef;
    pub fn CFNetServiceGetDomain(theService: CFNetServiceRef) -> CFStringRef;
    pub fn CFNetServiceGetType(theService: CFNetServiceRef) -> CFStringRef;
    pub fn CFNetServiceGetName(theService: CFNetServiceRef) -> CFStringRef;
    pub fn CFNetServiceRegisterWithOptions(
        theService: CFNetServiceRef,
        options: CFOptionFlags,
        error: *mut CFStreamError,
    ) -> Boolean;
    pub fn CFNetServiceResolveWithTimeout(
        theService: CFNetServiceRef,
        timeout: CFTimeInterval,
        error: *mut CFStreamError,
    ) -> Boolean;
    pub fn CFNetServiceCancel(theService: CFNetServiceRef);
    pub fn CFNetServiceGetTargetHost(theService: CFNetServiceRef) -> CFStringRef;
    pub fn CFNetServiceGetPortNumber(theService: CFNetServiceRef) -> SInt32;
    pub fn CFNetServiceGetAddressing(theService: CFNetServiceRef) -> CFArrayRef;
    pub fn CFNetServiceGetTXTData(theService: CFNetServiceRef) -> CFDataRef;
    pub fn CFNetServiceSetTXTData(theService: CFNetServiceRef, txtRecord: CFDataRef) -> Boolean;
    pub fn CFNetServiceCreateDictionaryWithTXTData(
        alloc: CFAllocatorRef,
        txtRecord: CFDataRef,
    ) -> CFDictionaryRef;
    pub fn CFNetServiceCreateTXTDataWithDictionary(
        alloc: CFAllocatorRef,
        keyValuePairs: CFDictionaryRef,
    ) -> CFDataRef;
    pub fn CFNetServiceSetClient(
        theService: CFNetServiceRef,
        clientCB: CFNetServiceClientCallBack,
        clientContext: *mut CFNetServiceClientContext,
    ) -> Boolean;
    pub fn CFNetServiceScheduleWithRunLoop(
        theService: CFNetServiceRef,
        runLoop: CFRunLoopRef,
        runLoopMode: CFStringRef,
    );
    pub fn CFNetServiceUnscheduleFromRunLoop(
        theService: CFNetServiceRef,
        runLoop: CFRunLoopRef,
        runLoopMode: CFStringRef,
    );
    pub fn CFNetServiceMonitorCreate(
        alloc: CFAllocatorRef,
        theService: CFNetServiceRef,
        clientCB: CFNetServiceMonitorClientCallBack,
        clientContext: *mut CFNetServiceClientContext,
    ) -> CFNetServiceMonitorRef;
    pub fn CFNetServiceMonitorInvalidate(monitor: CFNetServiceMonitorRef);
    pub fn CFNetServiceMonitorStart(
        monitor: CFNetServiceMonitorRef,
        recordType: CFNetServiceMonitorType,
        error: *mut CFStreamError,
    ) -> Boolean;
    pub fn CFNetServiceMonitorStop(monitor: CFNetServiceMonitorRef, error: *mut CFStreamError);
    pub fn CFNetServiceMonitorScheduleWithRunLoop(
        monitor: CFNetServiceMonitorRef,
        runLoop: CFRunLoopRef,
        runLoopMode: CFStringRef,
    );
    pub fn CFNetServiceMonitorUnscheduleFromRunLoop(
        monitor: CFNetServiceMonitorRef,
        runLoop: CFRunLoopRef,
        runLoopMode: CFStringRef,
    );
    pub fn CFNetServiceBrowserCreate(
        alloc: CFAllocatorRef,
        clientCB: CFNetServiceBrowserClientCallBack,
        clientContext: *mut CFNetServiceClientContext,
    ) -> CFNetServiceBrowserRef;
    pub fn CFNetServiceBrowserInvalidate(browser: CFNetServiceBrowserRef);
    pub fn CFNetServiceBrowserSearchForDomains(
        browser: CFNetServiceBrowserRef,
        registrationDomains: Boolean,
        error: *mut CFStreamError,
    ) -> Boolean;
    pub fn CFNetServiceBrowserSearchForServices(
        browser: CFNetServiceBrowserRef,
        domain: CFStringRef,
        serviceType: CFStringRef,
        error: *mut CFStreamError,
    ) -> Boolean;
    pub fn CFNetServiceBrowserStopSearch(
        browser: CFNetServiceBrowserRef,
        error: *mut CFStreamError,
    );
    pub fn CFNetServiceBrowserScheduleWithRunLoop(
        browser: CFNetServiceBrowserRef,
        runLoop: CFRunLoopRef,
        runLoopMode: CFStringRef,
    );
    pub fn CFNetServiceBrowserUnscheduleFromRunLoop(
        browser: CFNetServiceBrowserRef,
        runLoop: CFRunLoopRef,
        runLoopMode: CFStringRef,
    );
    pub fn CFNetServiceRegister(theService: CFNetServiceRef, error: *mut CFStreamError) -> Boolean;
    pub fn CFNetServiceResolve(theService: CFNetServiceRef, error: *mut CFStreamError) -> Boolean;
    pub static kCFStreamPropertySSLContext: CFStringRef;
    pub static kCFStreamPropertySSLPeerTrust: CFStringRef;
    pub static kCFStreamSSLValidatesCertificateChain: CFStringRef;
    pub static kCFStreamPropertySSLSettings: CFStringRef;
    pub static kCFStreamSSLLevel: CFStringRef;
    pub static kCFStreamSSLPeerName: CFStringRef;
    pub static kCFStreamSSLCertificates: CFStringRef;
    pub static kCFStreamSSLIsServer: CFStringRef;
    pub static kCFStreamNetworkServiceType: CFStringRef;
    pub static kCFStreamNetworkServiceTypeVideo: CFStringRef;
    pub static kCFStreamNetworkServiceTypeVoice: CFStringRef;
    pub static kCFStreamNetworkServiceTypeBackground: CFStringRef;
    pub static kCFStreamNetworkServiceTypeResponsiveData: CFStringRef;
    pub static kCFStreamNetworkServiceTypeCallSignaling: CFStringRef;
    pub static kCFStreamNetworkServiceTypeAVStreaming: CFStringRef;
    pub static kCFStreamNetworkServiceTypeResponsiveAV: CFStringRef;
    pub static kCFStreamNetworkServiceTypeVoIP: CFStringRef;
    pub static kCFStreamPropertyNoCellular: CFStringRef;
    pub static kCFStreamPropertyConnectionIsCellular: CFStringRef;
    pub static kCFStreamPropertyAllowExpensiveNetworkAccess: CFStringRef;
    pub static kCFStreamPropertyConnectionIsExpensive: CFStringRef;
    pub static kCFStreamPropertyAllowConstrainedNetworkAccess: CFStringRef;
    pub static kCFStreamErrorDomainWinSock: CFIndex;
    pub static kCFStreamPropertyProxyLocalBypass: CFStringRef;
    pub static kCFStreamPropertySocketRemoteHost: CFStringRef;
    pub static kCFStreamPropertySocketRemoteNetService: CFStringRef;
    pub static kCFStreamPropertySocketExtendedBackgroundIdleMode: CFStringRef;
    pub fn CFStreamCreatePairWithSocketToCFHost(
        alloc: CFAllocatorRef,
        host: CFHostRef,
        port: SInt32,
        readStream: *mut CFReadStreamRef,
        writeStream: *mut CFWriteStreamRef,
    );
    pub fn CFStreamCreatePairWithSocketToNetService(
        alloc: CFAllocatorRef,
        service: CFNetServiceRef,
        readStream: *mut CFReadStreamRef,
        writeStream: *mut CFWriteStreamRef,
    );
    pub static kCFStreamPropertySSLPeerCertificates: CFStringRef;
    pub static kCFStreamSSLAllowsExpiredCertificates: CFStringRef;
    pub static kCFStreamSSLAllowsExpiredRoots: CFStringRef;
    pub static kCFStreamSSLAllowsAnyRoot: CFStringRef;
    pub static kCFStreamErrorDomainFTP: SInt32;
    pub static kCFStreamPropertyFTPUserName: CFStringRef;
    pub static kCFStreamPropertyFTPPassword: CFStringRef;
    pub static kCFStreamPropertyFTPUsePassiveMode: CFStringRef;
    pub static kCFStreamPropertyFTPResourceSize: CFStringRef;
    pub static kCFStreamPropertyFTPFetchResourceInfo: CFStringRef;
    pub static kCFStreamPropertyFTPFileTransferOffset: CFStringRef;
    pub static kCFStreamPropertyFTPAttemptPersistentConnection: CFStringRef;
    pub static kCFStreamPropertyFTPProxy: CFStringRef;
    pub static kCFStreamPropertyFTPProxyHost: CFStringRef;
    pub static kCFStreamPropertyFTPProxyPort: CFStringRef;
    pub static kCFStreamPropertyFTPProxyUser: CFStringRef;
    pub static kCFStreamPropertyFTPProxyPassword: CFStringRef;
    pub static kCFFTPResourceMode: CFStringRef;
    pub static kCFFTPResourceName: CFStringRef;
    pub static kCFFTPResourceOwner: CFStringRef;
    pub static kCFFTPResourceGroup: CFStringRef;
    pub static kCFFTPResourceLink: CFStringRef;
    pub static kCFFTPResourceSize: CFStringRef;
    pub static kCFFTPResourceType: CFStringRef;
    pub static kCFFTPResourceModDate: CFStringRef;
    pub fn CFReadStreamCreateWithFTPURL(alloc: CFAllocatorRef, ftpURL: CFURLRef)
        -> CFReadStreamRef;
    pub fn CFFTPCreateParsedResourceListing(
        alloc: CFAllocatorRef,
        buffer: *const UInt8,
        bufferLength: CFIndex,
        parsed: *mut CFDictionaryRef,
    ) -> CFIndex;
    pub fn CFWriteStreamCreateWithFTPURL(
        alloc: CFAllocatorRef,
        ftpURL: CFURLRef,
    ) -> CFWriteStreamRef;
    pub static kCFHTTPVersion1_0: CFStringRef;
    pub static kCFHTTPVersion1_1: CFStringRef;
    pub static kCFHTTPVersion2_0: CFStringRef;
    pub static kCFHTTPVersion3_0: CFStringRef;
    pub static kCFHTTPAuthenticationSchemeBasic: CFStringRef;
    pub static kCFHTTPAuthenticationSchemeDigest: CFStringRef;
    pub static kCFHTTPAuthenticationSchemeNTLM: CFStringRef;
    pub static kCFHTTPAuthenticationSchemeKerberos: CFStringRef;
    pub static kCFHTTPAuthenticationSchemeNegotiate: CFStringRef;
    pub static kCFHTTPAuthenticationSchemeNegotiate2: CFStringRef;
    pub static kCFHTTPAuthenticationSchemeXMobileMeAuthToken: CFStringRef;
    pub fn CFHTTPMessageGetTypeID() -> CFTypeID;
    pub fn CFHTTPMessageCreateRequest(
        alloc: CFAllocatorRef,
        requestMethod: CFStringRef,
        url: CFURLRef,
        httpVersion: CFStringRef,
    ) -> CFHTTPMessageRef;
    pub fn CFHTTPMessageCreateResponse(
        alloc: CFAllocatorRef,
        statusCode: CFIndex,
        statusDescription: CFStringRef,
        httpVersion: CFStringRef,
    ) -> CFHTTPMessageRef;
    pub fn CFHTTPMessageCreateEmpty(alloc: CFAllocatorRef, isRequest: Boolean) -> CFHTTPMessageRef;
    pub fn CFHTTPMessageCreateCopy(
        alloc: CFAllocatorRef,
        message: CFHTTPMessageRef,
    ) -> CFHTTPMessageRef;
    pub fn CFHTTPMessageIsRequest(message: CFHTTPMessageRef) -> Boolean;
    pub fn CFHTTPMessageCopyVersion(message: CFHTTPMessageRef) -> CFStringRef;
    pub fn CFHTTPMessageCopyBody(message: CFHTTPMessageRef) -> CFDataRef;
    pub fn CFHTTPMessageSetBody(message: CFHTTPMessageRef, bodyData: CFDataRef);
    pub fn CFHTTPMessageCopyHeaderFieldValue(
        message: CFHTTPMessageRef,
        headerField: CFStringRef,
    ) -> CFStringRef;
    pub fn CFHTTPMessageCopyAllHeaderFields(message: CFHTTPMessageRef) -> CFDictionaryRef;
    pub fn CFHTTPMessageSetHeaderFieldValue(
        message: CFHTTPMessageRef,
        headerField: CFStringRef,
        value: CFStringRef,
    );
    pub fn CFHTTPMessageAppendBytes(
        message: CFHTTPMessageRef,
        newBytes: *const UInt8,
        numBytes: CFIndex,
    ) -> Boolean;
    pub fn CFHTTPMessageIsHeaderComplete(message: CFHTTPMessageRef) -> Boolean;
    pub fn CFHTTPMessageCopySerializedMessage(message: CFHTTPMessageRef) -> CFDataRef;
    pub fn CFHTTPMessageCopyRequestURL(request: CFHTTPMessageRef) -> CFURLRef;
    pub fn CFHTTPMessageCopyRequestMethod(request: CFHTTPMessageRef) -> CFStringRef;
    pub fn CFHTTPMessageAddAuthentication(
        request: CFHTTPMessageRef,
        authenticationFailureResponse: CFHTTPMessageRef,
        username: CFStringRef,
        password: CFStringRef,
        authenticationScheme: CFStringRef,
        forProxy: Boolean,
    ) -> Boolean;
    pub fn CFHTTPMessageGetResponseStatusCode(response: CFHTTPMessageRef) -> CFIndex;
    pub fn CFHTTPMessageCopyResponseStatusLine(response: CFHTTPMessageRef) -> CFStringRef;
    pub static kCFStreamErrorDomainHTTP: SInt32;
    pub static kCFStreamPropertyHTTPResponseHeader: CFStringRef;
    pub static kCFStreamPropertyHTTPFinalURL: CFStringRef;
    pub static kCFStreamPropertyHTTPFinalRequest: CFStringRef;
    pub static kCFStreamPropertyHTTPProxy: CFStringRef;
    pub static kCFStreamPropertyHTTPProxyHost: CFStringRef;
    pub static kCFStreamPropertyHTTPProxyPort: CFStringRef;
    pub static kCFStreamPropertyHTTPSProxyHost: CFStringRef;
    pub static kCFStreamPropertyHTTPSProxyPort: CFStringRef;
    pub static kCFStreamPropertyHTTPShouldAutoredirect: CFStringRef;
    pub static kCFStreamPropertyHTTPAttemptPersistentConnection: CFStringRef;
    pub static kCFStreamPropertyHTTPRequestBytesWrittenCount: CFStringRef;
    pub fn CFReadStreamCreateForHTTPRequest(
        alloc: CFAllocatorRef,
        request: CFHTTPMessageRef,
    ) -> CFReadStreamRef;
    pub fn CFReadStreamCreateForStreamedHTTPRequest(
        alloc: CFAllocatorRef,
        requestHeaders: CFHTTPMessageRef,
        requestBody: CFReadStreamRef,
    ) -> CFReadStreamRef;
    pub static kCFHTTPAuthenticationUsername: CFStringRef;
    pub static kCFHTTPAuthenticationPassword: CFStringRef;
    pub static kCFHTTPAuthenticationAccountDomain: CFStringRef;
    pub fn CFHTTPAuthenticationGetTypeID() -> CFTypeID;
    pub fn CFHTTPAuthenticationCreateFromResponse(
        alloc: CFAllocatorRef,
        response: CFHTTPMessageRef,
    ) -> CFHTTPAuthenticationRef;
    pub fn CFHTTPAuthenticationIsValid(
        auth: CFHTTPAuthenticationRef,
        error: *mut CFStreamError,
    ) -> Boolean;
    pub fn CFHTTPAuthenticationAppliesToRequest(
        auth: CFHTTPAuthenticationRef,
        request: CFHTTPMessageRef,
    ) -> Boolean;
    pub fn CFHTTPAuthenticationRequiresOrderedRequests(auth: CFHTTPAuthenticationRef) -> Boolean;
    pub fn CFHTTPMessageApplyCredentials(
        request: CFHTTPMessageRef,
        auth: CFHTTPAuthenticationRef,
        username: CFStringRef,
        password: CFStringRef,
        error: *mut CFStreamError,
    ) -> Boolean;
    pub fn CFHTTPMessageApplyCredentialDictionary(
        request: CFHTTPMessageRef,
        auth: CFHTTPAuthenticationRef,
        dict: CFDictionaryRef,
        error: *mut CFStreamError,
    ) -> Boolean;
    pub fn CFHTTPAuthenticationCopyRealm(auth: CFHTTPAuthenticationRef) -> CFStringRef;
    pub fn CFHTTPAuthenticationCopyDomains(auth: CFHTTPAuthenticationRef) -> CFArrayRef;
    pub fn CFHTTPAuthenticationCopyMethod(auth: CFHTTPAuthenticationRef) -> CFStringRef;
    pub fn CFHTTPAuthenticationRequiresUserNameAndPassword(
        auth: CFHTTPAuthenticationRef,
    ) -> Boolean;
    pub fn CFHTTPAuthenticationRequiresAccountDomain(auth: CFHTTPAuthenticationRef) -> Boolean;
    pub fn CFNetDiagnosticCreateWithStreams(
        alloc: CFAllocatorRef,
        readStream: CFReadStreamRef,
        writeStream: CFWriteStreamRef,
    ) -> CFNetDiagnosticRef;
    pub fn CFNetDiagnosticCreateWithURL(alloc: CFAllocatorRef, url: CFURLRef)
        -> CFNetDiagnosticRef;
    pub fn CFNetDiagnosticSetName(details: CFNetDiagnosticRef, name: CFStringRef);
    pub fn CFNetDiagnosticDiagnoseProblemInteractively(
        details: CFNetDiagnosticRef,
    ) -> CFNetDiagnosticStatus;
    pub fn CFNetDiagnosticCopyNetworkStatusPassively(
        details: CFNetDiagnosticRef,
        description: *mut CFStringRef,
    ) -> CFNetDiagnosticStatus;
    pub fn CFNetworkCopySystemProxySettings() -> CFDictionaryRef;
    pub fn CFNetworkCopyProxiesForURL(url: CFURLRef, proxySettings: CFDictionaryRef) -> CFArrayRef;
    pub fn CFNetworkCopyProxiesForAutoConfigurationScript(
        proxyAutoConfigurationScript: CFStringRef,
        targetURL: CFURLRef,
        error: *mut CFErrorRef,
    ) -> CFArrayRef;
    pub fn CFNetworkExecuteProxyAutoConfigurationScript(
        proxyAutoConfigurationScript: CFStringRef,
        targetURL: CFURLRef,
        cb: CFProxyAutoConfigurationResultCallback,
        clientContext: *mut CFStreamClientContext,
    ) -> CFRunLoopSourceRef;
    pub fn CFNetworkExecuteProxyAutoConfigurationURL(
        proxyAutoConfigURL: CFURLRef,
        targetURL: CFURLRef,
        cb: CFProxyAutoConfigurationResultCallback,
        clientContext: *mut CFStreamClientContext,
    ) -> CFRunLoopSourceRef;
    pub static kCFProxyTypeKey: CFStringRef;
    pub static kCFProxyHostNameKey: CFStringRef;
    pub static kCFProxyPortNumberKey: CFStringRef;
    pub static kCFProxyAutoConfigurationURLKey: CFStringRef;
    pub static kCFProxyAutoConfigurationJavaScriptKey: CFStringRef;
    pub static kCFProxyUsernameKey: CFStringRef;
    pub static kCFProxyPasswordKey: CFStringRef;
    pub static kCFProxyTypeNone: CFStringRef;
    pub static kCFProxyTypeHTTP: CFStringRef;
    pub static kCFProxyTypeHTTPS: CFStringRef;
    pub static kCFProxyTypeSOCKS: CFStringRef;
    pub static kCFProxyTypeFTP: CFStringRef;
    pub static kCFProxyTypeAutoConfigurationURL: CFStringRef;
    pub static kCFProxyTypeAutoConfigurationJavaScript: CFStringRef;
    pub static kCFProxyAutoConfigurationHTTPResponseKey: CFStringRef;
    pub static kCFNetworkProxiesExceptionsList: CFStringRef;
    pub static kCFNetworkProxiesExcludeSimpleHostnames: CFStringRef;
    pub static kCFNetworkProxiesFTPEnable: CFStringRef;
    pub static kCFNetworkProxiesFTPPassive: CFStringRef;
    pub static kCFNetworkProxiesFTPPort: CFStringRef;
    pub static kCFNetworkProxiesFTPProxy: CFStringRef;
    pub static kCFNetworkProxiesGopherEnable: CFStringRef;
    pub static kCFNetworkProxiesGopherPort: CFStringRef;
    pub static kCFNetworkProxiesGopherProxy: CFStringRef;
    pub static kCFNetworkProxiesHTTPEnable: CFStringRef;
    pub static kCFNetworkProxiesHTTPPort: CFStringRef;
    pub static kCFNetworkProxiesHTTPProxy: CFStringRef;
    pub static kCFNetworkProxiesHTTPSEnable: CFStringRef;
    pub static kCFNetworkProxiesHTTPSPort: CFStringRef;
    pub static kCFNetworkProxiesHTTPSProxy: CFStringRef;
    pub static kCFNetworkProxiesRTSPEnable: CFStringRef;
    pub static kCFNetworkProxiesRTSPPort: CFStringRef;
    pub static kCFNetworkProxiesRTSPProxy: CFStringRef;
    pub static kCFNetworkProxiesSOCKSEnable: CFStringRef;
    pub static kCFNetworkProxiesSOCKSPort: CFStringRef;
    pub static kCFNetworkProxiesSOCKSProxy: CFStringRef;
    pub static kCFNetworkProxiesProxyAutoConfigEnable: CFStringRef;
    pub static kCFNetworkProxiesProxyAutoConfigURLString: CFStringRef;
    pub static kCFNetworkProxiesProxyAutoConfigJavaScript: CFStringRef;
    pub static kCFNetworkProxiesProxyAutoDiscoveryEnable: CFStringRef;
}
